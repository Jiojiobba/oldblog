<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>React state组件状态（异步，合并更新） | Jiojio</title><meta name="description"><meta name="generator" content="Jiojio"><meta name="author" content="Jiojio"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/svdb.png" alt="Jiojio" title="Jiojio"></a><h1><a href="/" alt="Jiojio" title="Jiojio" itemprop="headline">Jiojio</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">React state组件状态（异步，合并更新）</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-11-22T08:53:59.000Z"> Friday, November 22nd 2019 at 16:53</time><br>Last updated on<time itemprop="dateModified" datetime="2019-11-22T08:53:59.000Z"> Friday, November 22nd 2019 at 16:54</time></span><h4 id="React-state组件状态（异步，参数）："><a href="#React-state组件状态（异步，参数）：" class="headerlink" title="React  state组件状态（异步，参数）："></a>React  state组件状态（异步，参数）：</h4><h5 id="State-的更新是异步的。"><a href="#State-的更新是异步的。" class="headerlink" title="State 的更新是异步的。"></a>State 的更新是异步的。</h5><ul>
<li>调用setState，组件的state并不会立即改变，setState只是把要修改的状态放入一个队列中，React会优化真正的执行时机，并且React会出于性能原因，可能会将多次setState的状态修改合并成一次状态修改。   </li>
<li>所以不要依赖当前的State，计算下个State。  </li>
<li>当真正执行状态修改时，依赖的this.state并不能保证是最新的State，因为React会把多次State的修改合并成一次，这时，this.state将还是这几次State修改前的State。    </li>
<li>另外需要注意的事，同样不能依赖当前的Props计算下个状态，因为Props一般也是从父组件的State中获取，依然无法确定在组件状态更新时的值。</li>
<li>举个例子，对于一个电商类应用，在我们的购物车中，当我们点击一次购买数量按钮，购买的数量就会加1，如果我们连续点击了两次按钮，就会连续调用两次</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;quantity: this.state.quantity + 1&#125;)</span><br></pre></td></tr></table></figure>

<p>在React合并多次修改为一次的情况下，相当于等价执行了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(</span><br><span class="line">  previousState,</span><br><span class="line">  &#123;quantity: this.state.quantity + 1&#125;,</span><br><span class="line">  &#123;quantity: this.state.quantity + 1&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>于是乎，后面的操作覆盖掉了前面的操作，最终购买的数量只增加了1个。<br>如果你真的有这样的需求，可以使用另一个接收一个函数作为参数的setState，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">this.setState((preState, props) =&gt; (&#123;</span><br><span class="line">  counter: preState.quantity + 1; </span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<ul>
<li>preState，props是可以直接用的</li>
<li>这个函数有两个参数：</li>
<li>第一个是当前最新状态（本次组件状态修改后的状态）的前一个状态preState（本次组件状态修改前的状态</li>
<li>第二个参数是当前最新的属性props。</li>
</ul>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>1.this.setState()参数可以是对象，可以是函数    </p>
<p>2.setState不会立刻改变React组件中state的值（即setState是异步更新）</p>
<ul>
<li>setState通过一个队列机制实现state更新；  </li>
<li>当执行setState时，会将需要更新的state合并后放入状态队列，而不会立即更新，队列可以高效的批量更新state；  </li>
</ul>
<p>3.setState通过引发一次组件的更新过程来引发重新绘制</p>
<ul>
<li>此处重绘指的就是引起React的更新生命周期函数4个函数：</li>
<li>shouldComponentUpdate（被调用时this.state没有更新；如果返回了false，生命周期被中断，虽然不调用之后的函数了，但是state仍然会被更新）</li>
<li>componentWillUpdate（被调用时this.state没有更新）</li>
<li>render（被调用时this.state得到更新）</li>
<li>componentDidUpdate</li>
</ul>
<p>4.多个相邻的state的修改可能会合并到一起一次执行，如果每次调用都引发一次生命周期更新，那性能就会消耗很大了。所以，React会将多个this.setState产生的修改放进一个队列里，等差不多的时候就会引发一次生命周期更新。</p>
<h6 id="个人理解："><a href="#个人理解：" class="headerlink" title="个人理解："></a>个人理解：</h6><ul>
<li><p>若以对象为参数：<br>因为setState是异步执行，不保证数据同步，是集齐一批需要更新的状态（这些批量更新的state状态会放在一个列表，这些state的前一个状态是同一个）然后一次性更新state状态，更新完才渲染，保证渲染性能，所以在使用setState改变状态之后，立刻通过this.state去拿最新的状态往往是拿不到的，所以state不能及时更换。  </p>
</li>
<li><p>若以函数为参数：<br>由于后面的数据会覆盖前面的更改，所以最终只加了一次.所以如果是下一个state依赖前一个state的话，推荐给setState传function为参数，因为回调函数会返回新的state，这个回调函数会在 setState 完成以后直接调用，这样就可以获取最新的 state 。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line"> constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = &#123;</span><br><span class="line">   count: 0</span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> componentDidMount() &#123;</span><br><span class="line">  let me = this;</span><br><span class="line">  me.setState(&#123;</span><br><span class="line">   count: me.state.count + 1</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(me.state.count);  // 打印出0</span><br><span class="line">  me.setState(&#123;</span><br><span class="line">   count: me.state.count + 1</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(me.state.count);  // 打印出0</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">   me.setState(&#123;</span><br><span class="line">    count: me.state.count + 1</span><br><span class="line">   &#125;);</span><br><span class="line">   console.log(me.state.count);  // 打印出2</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">   me.setState(&#123;</span><br><span class="line">    count: me.state.count + 1</span><br><span class="line">   &#125;);</span><br><span class="line">   console.log(me.state.count);  // 打印出3</span><br><span class="line">  &#125;, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> render() &#123;</span><br><span class="line">  return (</span><br><span class="line">   &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>参考：<br>1.<a href="https://www.jianshu.com/p/c6257cbef1b1" target="_blank" rel="noopener">https://www.jianshu.com/p/c6257cbef1b1</a><br>2.<a href="https://zhuanlan.zhihu.com/p/25882602" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25882602</a><br>3.<a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">https://zh-hans.reactjs.org/docs/state-and-lifecycle.html</a><br>4.<a href="https://segmentfault.com/a/1190000014990454" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014990454</a></p>
</article></main></body></html>