<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>开启react小项目 | Jiojio</title><meta name="description"><meta name="generator" content="Jiojio"><meta name="author" content="Jiojio"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/svdb.png" alt="Jiojio" title="Jiojio"></a><h1><a href="/" alt="Jiojio" title="Jiojio" itemprop="headline">Jiojio</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">开启react小项目</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-12-20T03:27:15.000Z"> Friday, December 20th 2019 at 11:27</time><br>Last updated on<time itemprop="dateModified" datetime="2019-12-20T03:27:15.000Z"> Friday, December 20th 2019 at 11:32</time></span><h6 id="12-19"><a href="#12-19" class="headerlink" title="12.19"></a>12.19</h6><h6 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h6><p>一、<br>dir列出当前目录下所有文件<br>.当前目录，..上级目录<br>md name 创建一个名为name的文件夹<br>rd name 删除一个name的文件夹<br>环境变量：windows系统中的变量（当在命令行窗口打开一个文件，或调用一个程序时，系统会首先在当前目录下寻找文件程序没如果找到则直接打开，如果没有则依次到环境变量path路径中找<br>进程：负载为程序运行提供必备的环境（代码存入到代码，like工厂的车间）    </p>
<p>二、<br>线程：计算机最小的计算单位，负载执行进程中的程序（like工人）<br>单线程：JS是单线程（怕会出冲突），主流是多线程</p>
<p>  三、<br>  在服务器端运行js的开放源代码、跨平台js运行环境（直接和系统交互，平台不是仅限于浏览器）<br>  Node使用事件驱动、非阻塞，异步I/O模型来提高性能<br>  以前：进一个请求，给分配一个线程，操作数据库有专门的I/O线程去操作，涉及到磁盘需要调用磁盘线程操作  于是便出现了阻塞（因为请求没有完，分配的线程就不能动，所以I/O的操作就阻塞了线程，这些阻塞的线程会占用内存）<br>  所以Node模式：所有请求就只有一个线程，单线程，不会因为I/O阻塞  </p>
<p>  四、<br>    Node的用途：<br>    Web服务API，比如REST<br>    实时多人游戏<br>    后端的web服务，例如跨域、服务器端的请求<br>    基于web的应用<br>    多客户端的通信，即时通信  </p>
<p>  五、<br>  Node的服务器是单线程的，但可以分布式（增加服务器的数量）  </p>
<p>六、<br>ECMAScript标准的缺陷：<br>1.没有模块系统：（模块化：一个完整 的程序分成一个个小程序，降低耦合性，方便代码复用），但有模块化（jQuery，但引入的模块过多也不好维护，因为引入的模块顺序)<br>2.标准库较少<br>3.没有标准接口<br>4.缺乏管理系统   </p>
<p>七、<br>在node中，通过require()函数来引入外部模块，require（）可传递一个文件的路径作为参数，node将会自动根据该路径引入外部模块，然后返回一个对象（引入的模块），require()引入外部模块时，使用的就是模块标识，用此来找到模块。<br>模块：核心模块（node引擎提供，它的标识就是模块的名字,e.g. var fs = require(“fs”)）、文件标识（用户自己创建的模块，它的标识就是文件路径）</p>
<p>八、<br>全局对象global<br>1.作用和网页的window相似，在全局中创建的变量/函数都会作为global的属性/方法保存。如何声明全局变量（a=10; 不要var，因为模块中的代码都是在函数里运行执行的，并且由nodejs引擎调用，在函数执行时，同时传递5个实参）<br>2.通过有无arguments判断是不是在函数里运行<br>3.callee该属性是保存的当前执行的函数对象<br>4.在node执行模块代码时，会首先在代码最顶部添加代码：<br>Function(exports,require,module,_filename,_dirname)<br>module是当前模块自身，exports是模块的属性（exoports == module.exports //true，本质一样没有区别）<br>_filename：当前模块的完整路径<br>_dirname：当前模块所在文件夹完整路径<br>因为模块中的代码都是在函数里运行执行的，并且由nodejs引擎调用，在函数执行时，同时传递5个实参  </p>
<h6 id="12-17"><a href="#12-17" class="headerlink" title="12.17"></a>12.17</h6><h6 id="VSCode保存React项目时，代码格式错乱"><a href="#VSCode保存React项目时，代码格式错乱" class="headerlink" title="VSCode保存React项目时，代码格式错乱"></a>VSCode保存React项目时，代码格式错乱</h6><p>左下角语言改成：JavaScript React</p>
<h6 id="Ant-Design"><a href="#Ant-Design" class="headerlink" title="Ant Design"></a>Ant Design</h6><p>按需打包：一个组件库定义了很多组件，但只用了几个，按照自己需求将这几打包；需要下载依赖模块<br>yarn add react-app-rewired customize-cra babel-plugin-import</p>
<p>  定义加载配置的js模块：<br>  针对antd按需打包，根据import来打包</p>
<h6 id="git"><a href="#git" class="headerlink" title="git"></a>git</h6><p>初始创建项目并推到git步骤：<br>git init 初始化本地仓库<br>git add . 暂存项目代码到本地仓库<br>git commit -m”init app”备注<br>git remote add origin xxxxxxx 链接远程仓库<br>git push -u origin master 发送请求：推送代码到远程仓库的master分支，此时本地默认是在master分支上<br>git checkout -b dev本地创建dev分支，并切换到dev分支，因为是从master切出来的，所以此时dev分支的代码跟master一样<br>git push origin dev 此时因为上面命令，本地已经在dev分支，这时是将本地的dev分支推送到远程的dev分支，（一般是在dev写几个模块之后再融合到master分支）</p>
<p>另外：<br>1.git clone 2.xxxxx从远程克隆项目代码（master，dev）<br>3.git branch克隆完了之后，查看远程分支（结果只有master，因为本地还没有创建dev）<br>4.git checkout -b dev origin/dev根据远程的dev创建本地的dev，此时是在dev分支<br>5.git pull origin dev从远程的dev拉取到本地的dev分支</p>
<h6 id="开发环境、测试环境、生产环境-区别"><a href="#开发环境、测试环境、生产环境-区别" class="headerlink" title="开发环境、测试环境、生产环境 区别"></a>开发环境、测试环境、生产环境 区别</h6><p>开发环境（development）：开发环境是程序猿们专门用于开发的服务器，配置可以比较随意， 为了开发调试方便，一般打开全部错误报告。(程序员接到需求后，开始写代码，开发，运行程序，看看程序有没有达到预期的功能；)</p>
<p>测试环境（testing）：一般是克隆一份生产环境的配置，一个程序在测试环境工作不正常，那么肯定不能把它发布到生产机上。(程序员开发完成后，交给测试部门全面的测试，看看所实现的功能有没有bug，测试人员会模拟各种操作情况；)</p>
<p>生产环境（production）：是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(就是线上环境，发布到对外环境上，正式提供给客户使用的环境。)</p>
<p>三个环境也可以说是系统开发的三个阶段：开发-&gt;测试-&gt;上线，其中生产环境也就是通常说的真实环境。  </p>
<p>原文链接：<a href="https://blog.csdn.net/yanglangdan/article/details/102552388" target="_blank" rel="noopener">https://blog.csdn.net/yanglangdan/article/details/102552388</a><br>————————————————<br>通俗一点就是：</p>
<p>1：开发环境：项目尚且在编码阶段，我们的代码一般在开发环境中 不会在生产环境中，生产环境组成：操作系统，web服务器，语言环境，php，数据库 等等</p>
<p>2：测试环境：项目完成测试，修改bug阶段</p>
<p>3：生产环境：项目数据前端后台已经跑通，部署在阿里云上之后，有客户使用，访问，就是网站正式运行了<br>转载：<a href="https://blog.csdn.net/qq_36538012/article/details/78552074" target="_blank" rel="noopener">https://blog.csdn.net/qq_36538012/article/details/78552074</a></p>
</article></main></body></html>