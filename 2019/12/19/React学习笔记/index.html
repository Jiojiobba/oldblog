<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>React学习笔记 | Jiojio</title><meta name="description"><meta name="generator" content="Jiojio"><meta name="author" content="Jiojio"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/svdb.png" alt="Jiojio" title="Jiojio"></a><h1><a href="/" alt="Jiojio" title="Jiojio" itemprop="headline">Jiojio</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline">React学习笔记</h1><span class="post-meta">Published on<time itemprop="datePublished" datetime="2019-12-19T03:04:45.000Z"> Thursday, December 19th 2019 at 11:04</time><br>Last updated on<time itemprop="dateModified" datetime="2019-12-19T03:04:45.000Z"> Friday, December 20th 2019 at 11:32</time></span><h6 id="12-18"><a href="#12-18" class="headerlink" title="12.18"></a>12.18</h6><h6 id="配置路由器"><a href="#配置路由器" class="headerlink" title="配置路由器"></a>配置路由器</h6><p>最外层是路由器，路由器里面要配置路由，每个路由就是一个标签，路由里面要配置，一个路由是一个映射关系（key：path，value：组件）<br>引入组件名要大小</p>
<h6 id="12-17"><a href="#12-17" class="headerlink" title="12.17"></a>12.17</h6><h6 id="react初始项目"><a href="#react初始项目" class="headerlink" title="react初始项目"></a>react初始项目</h6><p>1.一个react项目都会有一个入口js(名字必须是index.js），也必须有一个根组件（一般叫App.js/App.jxs)<br>一个组件如何定义：<br>简单的组件：函数<br>相对复杂的组件：类定义<br>  e.g. 在App.js里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;//包名小写</span><br><span class="line">import ReactDOM from &apos;react-dom&apos;</span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line">  render ()&#123;</span><br><span class="line">    return &lt;div&gt;App&lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入第三方模块，引入自定义模块需要加./或者../等等<br>  extends Component，即继承Component ，Component是React对象的一个属性，所以可以这么引入important React, {Component} from ‘react’</p>
<p>  这个内组件必须有个render方法，且这个方法必须返回一个虚拟DOM对象（这个虚拟DOM对象是要用CSS标签语法写），最终生成的是真实的div标签对象</p>
<p>  2.开始写代码前会创建项目源码的基本目录结构，在src文件夹下：<br>api ajax相关<br>assets 公用资源（样式/组件）<br>components非路由组件<br>config配置<br>pages路由组件<br>utils工具模块（格式化/存储等）<br>App.js应用根组件<br>index.js入口js  </p>
<p> 3.检查：F12，React<br> 4.react组件命名开头必须大写</p>
<h6 id="12-10"><a href="#12-10" class="headerlink" title="12.10"></a>12.10</h6><h6 id="react应用（基于脚手架）全家桶"><a href="#react应用（基于脚手架）全家桶" class="headerlink" title="react应用（基于脚手架）全家桶"></a>react应用（基于脚手架）全家桶</h6><p>（真正的项目需要大的环境，写一些配置，有很多依赖）（脚手架实际上是一个库，能创建空的项目（没有自己写的代码，但结构、配置、依赖都写好了）<br>1.使用</p>
<h6 id="脚手架应用分析"><a href="#脚手架应用分析" class="headerlink" title="脚手架应用分析"></a>脚手架应用分析</h6><p>pakage.json里面可以看它依赖那个包<br>1.dependencies:运行时式依赖（运行的时候打包<br>devDependencies:开发式依赖（编译打包时候需要；包含react-scripts这个里面有很多个包<br>脚手架里将它所有编译打包的功能都封装到react-scripts<br>webpack应用必须有个入口js,入口js一般靠配置配的，有两种名称index，main.js比较常见  </p>
<p>2..gitignore git管理的忽略控制<br>3.pakage，是当前应用的包，应用里面下载的每一个都是包，包就是一个应用（因为pakage.json信息文件是包的描述文件，用来描述当前项目先关信息的）<br>pakage.json：<br>1.当前包的标识，是别人来引用我这个项目的（name：名称（不变），version：版本号（可以变））<br>2.当前包的依赖（运行/开发依赖：dependencies，devDependencies）<br>3.当前应用如何运行/打包，命令：scripts里面，通过npm run运行</p>
<h6 id="12-09"><a href="#12-09" class="headerlink" title="12.09"></a>12.09</h6><h6 id="虚拟DOM-diff算法"><a href="#虚拟DOM-diff算法" class="headerlink" title="虚拟DOM diff算法"></a>虚拟DOM diff算法</h6><p>虚拟DOM：减少操作原生DOM，最小化页面重绘,减少更新页面次数；<br>一、DOM  diff算法：判断那片区域需要更新，哪片不需要更新<br>  ==React是如何做到效率高的：==<br>  初始化显示界面过程：<br>  1.创建虚拟DOM树（一般JS对象，不是真实的DOM），render方法返回的是虚拟DOM树（是js对象），更新虚拟DOM界面不会变，更新真实DOM，界面才会变。我们不需要更新真实DOM，我们只需要更新虚拟DOM。如何触发虚拟DOM更新只需要更新状态，虚拟DOM就会产生<br>  2.真实DOM树<br>  3.绘制界面显示  </p>
<p>  更新界面：<br>  1.setState（）更新状态，因为setState指定了新的状态对象，以前有一个老的状态，现在是新的状态，他们是会进行比较，如果状态直接用”=”修改，则会把以前的状态改了，就没有新旧状态对比；而新旧数据的差异就会转换成虚拟DOM的差异<br>  2.重新创建虚拟DOM树<br>  3.新/旧两个树比较差异（此时便需要diff算法，实现最小重绘）<br>  4.更新差异对应的真实DOM<br>  5.局部页面重绘  </p>
<h6 id="生命周期："><a href="#生命周期：" class="headerlink" title="生命周期："></a>生命周期：</h6><p>生命周期回调函数，回调函数（你定义的但你没有调用，但最终执行了，like render方法），即生命周期的勾子，这些函数在特定的时刻调用，而且不同的方法在不同的时候调用  </p>
<p>声明式编程：整个流程已经设定好了，如果不重写这些生命周期回调函数，就没法做自己想做的事情</p>
<p>命令式编程：jQuery每一步都是自己写，每个流程都自己在操作控制  </p>
<p>  constructor（）{}创建组件实例的时候会调用的一个方法<br>  render（）{}只要状态变了，就会调用render（）{}<br>componentWillUnmount（）{}<br>componentWillMount()组件将要挂载！<br>挂载：一开始虚拟DOM是在内存里面，最终用render把他插入到某个页面的容器，这个过程叫做挂载，挂载到页面上去  </p>
<p>生命周期流程：<br>1&gt;第一次初始化渲染显示：render<br>constructor：创建对象初始化state<br>componentWillMount：将要插入回调<br>render用于插入虚拟DOM<br>componentDidMount已经插入回调    </p>
<p>2&gt;每次更新state：this.setState()<br>componentWillUpdate：将要更新回调<br>render：更新（重新渲染）  componentDidUpdate：已经更新回调  </p>
<p>3&gt;移除组件：unmountComponentAtNode（）组件将要被移除回调</p>
<h6 id="受控组件，非受控组件"><a href="#受控组件，非受控组件" class="headerlink" title="受控组件，非受控组件"></a>受控组件，非受控组件</h6><h6 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h6><p>event.preventDefault()</p>
<h6 id="1-this"><a href="#1-this" class="headerlink" title="1.this"></a>1.this</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  // 此语法确保 `handleClick` 内的 `this` 已被绑定。</span><br><span class="line">  // 注意: 这是 *实验性* 语法。</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(&apos;this is:&apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>class LoggingButton extends React.Component {
  handleClick() {
    console.log(&apos;this is:&apos;, this);
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    return (
      &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}</code></pre><h6 id="2-key"><a href="#2-key" class="headerlink" title="2.key"></a>2.key</h6><p>1.帮助React识别哪些元素改变了（添加、删除），作为数组元素一个确定的标识。  </p>
<p>2.一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key  </p>
<p>3.当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key</p>
<p>4.如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。  </p>
<h6 id="为什么key是必须的"><a href="#为什么key是必须的" class="headerlink" title="为什么key是必须的"></a>为什么key是必须的</h6><p>1.索引作为key，id作为key  </p>
<h6 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h6><p>1.表示组件内部的某个元素  </p>
<h6 id="state"><a href="#state" class="headerlink" title="state"></a>state</h6><p>1.状态一般是组件内部的变化，而且一般会变，props是组件外部传进来的，一般是写标签的时候传进来的  </p>
<h6 id="组件化编码的流程"><a href="#组件化编码的流程" class="headerlink" title="组件化编码的流程"></a>组件化编码的流程</h6><p>1.拆分组件：拆分界面，抽取组件<br>2.实现静态组件：使用组件实现静态页面效果<br>3.实现动态组件：1动态显示初始化数据 2交互功能（从绑定事件监听开始）  </p>
<p>==注意：==<br>数据放到哪个组件内<br>依据：看数据是某个组件（给他）需要还是某些组件需要（给共同的父亲）<br>==注意：==<br>在子组件中改变父组件的状态：  </p>
<p>因为子组件中不能直接setstate改变父组件状态  </p>
<p>状态在哪个组件，更新状态的行为（函数/方法）就应该定义在哪个组件   （父子组件，不是继承关系，是位置的嵌套关系)</p>
<p>父组件定义函数，传递给子组件，子组件调用<br>(若在父组件定义的，则在渲染时需要传给子组件，addTodo={this.addTodo},然后再在子组件onClick={todo}  todo函数里面this.props.addTodo（参数）调用)<br>==注意：==<br>Add.propTypes = {<br>    count: PropTypes.number.isRequired,<br>    addTodo: PropTypes.function.isRequired<br>}</p>
</article></main></body></html>